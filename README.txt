Задача 1:
	Так же задачу можно было решить перебором всех элементов массива, но этот способ совсем не хороший.
	(по типу:  i =1
		   while i < len(array):
			if array[i] == 1:
				return i
			i+=1 )
	Но это плохая кострукция... 

Задача 2:
	Дело в том, что в Википедии на некоторые буквы встречаются слова, начинающиеся на другую букву...
	Поэтому дополнительно были отсортированы полученные данные.
	Так же данную задачу можно было решить с помощью BeautifulSoup, как обычный парсер. Это было бы более практично. 
Так как selenium webdriver обычно используется для тестирования приложений.

Задача 3:
	Логика такова: 
	Ведем три списка по 2 элемента less_interv,  stud_interv, teach_interv в которых содержим время входа и выхода лекции, студента, и учителя соответсвенно.
	i_teach, i_stud содержат следующий элемент соответсвующего массива(stud, teach)
	далее в цикле (пока один из массивов не будет пройдет(stud, teach)) следующие действия: идет проверка на вхождение в текущий интевар других интервальных массивов, если данное время входи, его вносим 
в резулитьтирующий список интервалов, затем сдвигаем интревальный массив.
	Таким образом в списке res_int содержатся время прихода и учителя на леуии одновременно с тем когдабыла лекция. Т е пересечение трех множеств.
	Так как в задаче нужно общее время, то вычитая из каждого слож элемента предыдущий ноходим его.
	
	Задачу можно было решить другим способом более простом с точки зрения понимания, но не эффетивным по скорости и память.
	Можно было при помощи range(нач, конец, 1) создать тря явных множдества с каждой секундой. множдества были бы большими.
	И далее просто найти пересечение множеств.